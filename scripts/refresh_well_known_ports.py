"""Fetch the latest version of IANA document "Service Name and Transport Protocol Port Number Registry"[1], and
reconstruct the file "data/well-known-ports.yaml".

[1]: https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv
"""

from collections import defaultdict
import csv
from datetime import datetime, timezone
from io import StringIO
import logging
import re
import urllib.request
import yaml


URL = "https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv"


def main():
    with urllib.request.urlopen(URL) as f:
        web_csv = f.read().decode('utf-8')
    # with open('./service-names-port-numbers.csv') as f:
    #     web_csv = f.read()
    dialect = csv.Sniffer().sniff(web_csv[0:1024])
    reader = csv.reader(StringIO(web_csv), dialect=dialect)

    well_known_ports = defaultdict(set)
    for row in reader:
        if len(row) <= 3:
            continue
        if re.match(r'\(?unassigned\)?', row[3], flags=re.IGNORECASE):
            # print('unassigned')
            continue
        if re.match(r'reserved', row[3], flags=re.IGNORECASE):
            # print('reserved')
            continue
        if re.match(r'removed', row[3], flags=re.IGNORECASE):
            # print('removed')
            continue
        if re.match(r'de-registered', row[3], flags=re.IGNORECASE):
            # print('de-registered')
            continue
        if re.match(r'deprecated', row[3], flags=re.IGNORECASE):
            # print('deprecated')
            continue
        if re.match(r'de\-?comm?issioned', row[3], flags=re.IGNORECASE):
            # print('decomissioned')
            continue
        if re.match(r'decomissioned', row[3], flags=re.IGNORECASE):
            # print('decomissioned')
            continue

        label, port, proto, _description = row[:4]
        if label and port and proto and str(port).isdigit():
            label = re.sub(r'\W', '_', str(label).upper())
            port = int(port)
            well_known_ports[label].add((port,proto))
            continue

    result = {}
    for label, values in well_known_ports.items():
        by_port = defaultdict(set)
        for (port, proto) in values:
            by_port[port].add((port, proto))
        if len(by_port.keys()) > 1:
            logging.debug('DEBUG: MULTI-KEY', label, f'{list(by_port.keys())}')
            result[label] = []
            for port, values in by_port.items():
                sub_label = f'{label}_{port}'
                result[sub_label] = [{'port': port, 'protocol': proto} for port, proto in sorted(values)]
                result[label].append({'name': sub_label})
            result[label].sort(key=lambda x: x['name'])
        else:
            result[label] = [{'port': port, 'protocol': proto} for port, proto in sorted(values)]
    
    # Custom adjustments
    if 'HTTP_ALT' in result:
        # jtwb: HTTP_ALT is typically just 8080
        result['HTTP_ALT_ALL'] = result['HTTP_ALT']
        result['HTTP_ALT'] = result['HTTP_ALT_8080']
        del result['HTTP_ALT_8080']
        result['HTTP_ALT_ALL'] = sorted([entry if entry['name'] != 'HTTP_ALT_8080' else {'name': 'HTTP_ALT'} for entry in result['HTTP_ALT_ALL']], key=lambda x: x['name'])

    result = yaml.safe_dump({'services': result})
    print(f'''
# Generated by scripts/refresh_well_known_ports.py
# Retrieved from "{URL}" at {datetime.now(timezone.utc)}
''')
    print(result)

if __name__ == '__main__':
    main()